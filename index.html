
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>JS Tokens, Expressions, Statements</title>

  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <aside>
    <nav id="navbar">
      <header>
        <h1>JavaScript<br>Tokens<br>Expressions<br>Statements</h1>
      </header>

      <ul>
        <li>
          <a class="nav-link" href="#tokens">Tokens</a>
        </li>
        <li>
          <a class="nav-link" href="#simple_expressions">Simple Expressions</a>
        </li>
        <li>
          <a class="nav-link" href="#compound_literal_expressions">Compound<br>Literal Expressions</a>
        </li>
        <li>
          <a class="nav-link" href="#operator_expressions">Operator Expressions</a>
        </li>
        <li>
          <a class="nav-link" href="#nested_expressions">Nested Expressions</a>
        </li>
        <li>
          <a class="nav-link" href="#statements">Statements</a>
        </li>
      </ul>
    </nav>

    <h3>DISCLAIMER</h3>

    <p class="disclaimer">
      All this categorization is a bit subjective
      and is not to be taken as a definitive list
      of all the tokens in JavaScript.<br>
      Literature and highligters can use
      less or more detailed categorizations.<br>
      Some tokens may be put in more than one category.<br>
      Expressions and statements can be named in different ways.<br>
    </p>
  </aside>

  <main id="main-doc">
    <section id="tokens" class="main-section">
      <header>
        <h2>Tokens</h2>
      </header>

      <p>
        Tokens are the smallest building blocks of a programming language. Atomic units of code, like words and punctuation marks in human languages. You can further break them into letters, digits and other characters, of course, code is just text after all. But they will loose their meaning then, so the smallest meaningful units we consider are tokens.
      </p>

      <p>Easy to remember mnemonic (memorization trick) for the six categories of tokens I suggest is below:</p>

      <div class="code-block">
        <code>const m = 'Nemo'; // nick</code>
      </div>

      <ul class="legend">
        <li><code>const</code> &nbsp; - keyword</li>
        <li><code>m</code> &nbsp; &nbsp; &nbsp; - identifier</li>
        <li><code>=</code> &nbsp; &nbsp; &nbsp; - operator</li>
        <li><code>'Nemo'</code> &nbsp; - literal</li>
        <li><code>;</code> &nbsp; &nbsp; &nbsp; - punctuator</li>
        <li><code>// nick</code> &nbsp; - comment</li>
      </ul>

      <h3>keywords</h3>

      <ul class="columns">
        <li><code>var</code></li>
        <li><code>let</code></li>
        <li><code>const</code></li>
        <li><code>function</code></li>
        <li><code>return</code></li>
        <li><code>class</code></li>
        <li><code>static</code></li>
        <li><code>if</code> &nbsp;*</li>
        <li><code>else</code></li>
        <li><code>do</code></li>
        <li><code>while</code></li>
        <li><code>for</code></li>
        <li><code>of</code></li>
        <li><code>in</code> &nbsp;**</li>
        <li><code>break</code></li>
        <li><code>continue</code></li>
        <li><code>yield</code> &nbsp;**</li>
        <li><code>switch</code></li>
        <li><code>case</code></li>
        <li><code>default</code></li>
        <li><code>throw</code></li>
        <li><code>try</code></li>
        <li><code>catch</code> &nbsp;***</li>
        <li><code>finally</code> &nbsp;***</li>
        <li><code>new</code> &nbsp;**</li>
        <li><code>delete</code> &nbsp;***</li>
        <li><code>typeof</code> &nbsp;**</li>
        <li><code>instanceof</code> &nbsp;**</li>
        <li><code>get</code> &nbsp;***</li>
        <li><code>set</code> &nbsp;***</li>
        <li><code>async</code></li>
        <li><code>await</code> &nbsp;**</li>
        <li><code>import</code></li>
        <li><code>export</code></li>
        <li><code>debugger</code></li>
        <li><code>void</code></li>
        <li><code>with</code></li>
        <li><code>this</code> &nbsp;***</li>
        <li><code>constructor</code> &nbsp;***</li>
        <li><code>super</code> &nbsp;***</li>
        <li><code>arguments</code> &nbsp;***</li>
        <li><code>null</code> &nbsp;****</li>
        <li><code>undefined</code> &nbsp;****</li>
        <li><code>true</code> &nbsp;****</li>
        <li><code>false</code> &nbsp;****</li>
        <li><code>Infinity</code> &nbsp;****</li>
        <li><code>NaN</code> &nbsp;****</li>
      </ul>

      <p class="note">
        * <code>if</code> is called an operator sometimes out of tradition.
      </p>

      <p class="note">
        ** <code>in</code>, <code>new</code>, <code>delete</code>, <code>typeof</code>, <code>instanceof</code>, <code>yield</code> and <code>await</code> are also considered operators by some as they have specific precedence rules. Although syntax highligters color them as keywords more often.
      </p>

      <p class="note">
        *** <code>this</code>, <code>constructor</code>, <code>super</code>, <code>arguments</code>, <code>null</code>, <code>undefined</code>, <code>true</code>, <code>false</code>, <code>Infinity</code> and <code>NaN</code> are also sometimes considered identifiers we're unable to assign using them, only read the corresponding values. <code>get</code>, <code>set</code>, <code>delete</code>, <code>catch</code>, <code>finally</code> on the other hand are actually used as property (method) identifiers quite often.
      </p>

      <p class="note">
        **** <code>null</code>, <code>undefined</code>, <code>true</code>, <code>false</code>, <code>Infinity</code> and <code>NaN</code> can also be viewed as respective type literals used to "create" corresponding values.
      </p>

      <h3>identifiers</h3>

      <p>Identifiers are the names of any and all binding entities that are not keywords:</p>

      <ul class="columns">
        <li>variables</li>
        <li>constants</li>
        <li>functions</li>
        <li>parameters</li>
        <li>properties</li>
        <li>methods</li>
        <li>classes</li>
      </ul>

      <p>Any identifier is a subject to valid identifier rules:</p>

      <ul class="legend">
        <li>should not match keywords *</li>
        <li>should not start with a digit</li>
        <li>should not contain spaces</li>
        <li>should not contain operators or punctuators</li>
        <li>should not contain special characters **</li>
      </ul>

      <p class="note">
        * identifiers can not match reserved keywords, but they can match some non-reserved keywords. Please don't use those to name your bindings anyway.
      </p>

      <p class="note">
        ** <code>$</code> and <code>_</code> are commonly used in identifiers. Non-English letters are also allowed, as well as many other characters. But again, please don't use them in your binding names. Follow the conventions.
      </p>

      <h3>operators</h3>

      <p>
        Operators are the symbols that perform operations on operands. They are used to manipulate values, to compare them, to assign them, to call functions, and so on. Operators are also used to group expressions together, for example to create a function call.
      </p>

      <ul class="columns">
        <li><code>+</code></li>
        <li><code>-</code></li>
        <li><code>*</code></li>
        <li><code>/</code></li>
        <li><code>%</code></li>
        <li><code>**</code></li>
        <li><code>=</code></li>
        <li><code>==</code></li>
        <li><code>!=</code></li>
        <li><code>===</code></li>
        <li><code>!==</code></li>
        <li><code>&lt;</code></li>
        <li><code>&lt;=</code></li>
        <li><code>&gt;</code></li>
        <li><code>&gt;=</code></li>
        <li><code>++</code></li>
        <li><code>--</code></li>
        <li><code>!</code></li>
        <li><code>&&</code></li>
        <li><code>||</code></li>
        <li><code>??</code></li>
        <li><code>? :</code></li>
        <li><code>+=</code></li>
        <li><code>-=</code></li>
        <li><code>*=</code></li>
        <li><code>/=</code></li>
        <li><code>%=</code></li>
        <li><code>**=</code></li>
        <li><code>&&=</code></li>
        <li><code>||=</code></li>
        <li><code>??=</code></li>
        <li><code>.</code></li>
        <li><code>?.</code></li>
        <li><code>[ ]</code></li>
        <li><code>( )</code></li>
        <li><code>...</code></li>
        <li><code>,</code></li>
        <li><code>&</code></li>
        <li><code>|</code></li>
        <li><code>^</code></li>
        <li><code>~</code></li>
        <li><code>&gt;&gt;</code></li>
        <li><code>&lt;&lt;</code></li>
        <li><code>&gt;&gt;&gt;</code></li>
      </ul>

      <p>MDN documentation puts operators in categories as such:</p>

      <ul class="legend">
        <li><code>arithmetic</code></li>
        <li><code>assignment</code></li>
        <li><code>increment/decrement</code></li>
        <li><code>accessors</code></li>
        <li><code>unary</code></li>
        <li><code>relational</code></li>
        <li><code>equality</code></li>
        <li><code>logical</code></li>
        <li><code>ternary</code></li>
        <li><code>call</code></li>
        <li><code>bitwise logical</code></li>
        <li><code>bitwise shift</code></li>
        <li><code>other...</code></li>
      </ul>

      <h3>literals</h3>

      <p>
        Literals are the code fragments that are supposed to be the values written literally in the source code. A literal is basically a command to the computer to create and return a value. There are no values in the code. No numbers, no strings or other types of values. The closest thing to a value in code is a corresponding literal.
      </p>

      <p>There are several kinds of single token literals in JavaScript:</p>

      <ul class="legend">
        <li><code>'lit'</code>, <code>"lit"</code>, <code>`lit`</code> - string literals</li>
        <li><code>123</code>, <code>-4</code>, <code>0.56</code>, <code>4e6</code>, <code>2e-5</code>, <code>1_000_000</code> - number literals</li>
        <li><code>0b10</code>, <code>0o777</code>, <code>0xFF</code>, - number literals in binary, octal, hexadecimal</li>
        <li><code>NaN</code>, <code>Infinity</code> * - also produce number type values</li>
        <li><code>true</code>, <code>false</code> * - boolean literals</li>
        <li><code>null</code>, <code>undefined</code> * - singular values of monotypes</li>
        <li><code>1234567890n</code> - big integer literal</li>
      </ul>

      <p class="note">
        * <code>NaN</code>, <code>Infinity</code>, <code>true</code>, <code>false</code>, <code>null</code> and <code>undefined</code> although written with keywords and internally working as read-only identifiers are indeed used as literals producing the corresponding values.
      </p>

      <h3>punctuators</h3>

      <p>
        Punctuators (or punctuation) are the symbols that syntactically separate or group other tokens in a source code. They are required or recommended in certain constructions where they are used to clearly define the structure of the code. Punctuators are formal tokens and unlike operators, they do not perform any operations on operands.
      </p>

      <ul class="columns">
        <li> <code>,</code> *</li>
        <li> <code>;</code> </li>
        <li> <code>:</code> </li>
        <li> <code>( )</code> *</li>
        <li> <code>[ ]</code> *</li>
        <li> <code>{ }</code> </li>
        <li> <code>${ }</code> </li>
      </ul>

      <p class="note">
        * <code>,</code>, <code>( )</code>, <code>[ ]</code> and <code>{ }</code> would work as operators or literals in some positions and as punctuators in others, but don't worry the syntax is totally deterministic and makes it clear which is which.
      </p>

      <h3>comments</h3>

      <p>
        Comments are written in the source code to explain the code or to temporarily disable some parts of it. They are ignored by the JavaScript engine and are not executed. Although some very specific comments can sometimes be interpreted by other utilities in the web developer's tooling, like editors, linters, transpilers, compilers, bundlers etc.
      </p>

      <ul class="legend">
        <li>
          <code>// comment to the end of the line</code>
        </li>

        <br>

        <li>
          <code>/* partial inline comment */</code>
        </li>

        <br>

        <li>
          <code>
            <pre>/*<br>  multiline<br>  comment<br>*/</pre>
          </code>
        </li>

        <br>

        <li>
          <code>
            <pre>/**<br> * JSDoc comment<br> *<br> * @param {type} identifier<br> * @returns {type}<br> * @throws {type}<br> * @example<br> *   example code<br> */</pre>
          </code>
        </li>
      </ul>

      <p class="note">
        * JSDoc comments are recognized by TypeScript, code editors, IDEs and some other tools and can be quite handy to denote the parameter names, expected types, return values, and so on.
      </p>
    </section>

    <section id="simple_expressions" class="main-section">
      <header>
        <h2>Simple Expressions</h2>
      </header>

      <p>Simple expressions are the singular tokens that can be evaluated on their own and so make the simplest expressions. Simple expressions can be used as the operands of operators, as the arguments of function calls, and so on.</p>

      <p>Literal expression is basically a command to the computer to produce a value (create in memory and return it or the corresponding memory address to get the value).</p>

      <h4>Number literals:</h4>

      <div class="code-block">
        <code>
          <pre>42<br>3.14<br>12e9<br>2e-5<br>1_000_000<br>0b10<br>0o777<br>0xFF<br>NaN<br>Infinity</pre>
        </code>
      </div>

      <h4>BigInt literals:</h4>

      <div class="code-block">
        <code>
          <pre>1234567890n<br>-14n<br>99999999999999999999999999999999n</pre>
        </code>
      </div>

      <h4>String literals:</h4>

      <div class="code-block">
        <code>
          <pre>'Hi!'<br>"Hello World"<br>'O\'Reilly'<br>"He said, \"Hello!\""<br>`no interpolation`</pre>
        </code>
      </div>

      <h4>Boolean literals:</h4>

      <div class="code-block">
        <code>
          <pre>true<br>false</pre>
        </code>
      </div>

      <h4>Null and undefined literals:</h4>

      <div class="code-block">
        <code>
          <pre>null<br>undefined</pre>
        </code>
      </div>

      <h4>Empty array and object literals:</h4>

      <div class="code-block">
        <code>
          <pre>[]<br>{}</pre>
        </code>
      </div>

      <h4>Regular expression (regex) literals: *</h4>

      <div class="code-block">
        <code>
          <pre>/.*/<br>/^(ab+|c*)\d?[ef]$/gi</pre>
        </code>
      </div>

      <p class="note">
        * regex literal is a single token as far as the JavaScript engine is concerned. But on a deeper level of regular expressions as a meta-language, it is a sequence of regex-tokens.
      </p>

      <h4>Identifier expressions:</h4>

      <p>Single identifiers are "read binding value" commands. Here are some example constant, variable, parameter, function or class names:</p>

      <div class="code-block">
        <code>
          <pre>x0<br>parseInt<br>Object<br>console<br>myCustomVariable<br>doSomething<br>param1</pre>
        </code>
      </div>

      <p>standalone keyword bindings are simialar to identifiers: *</p>

      <div class="code-block">
        <code>
          <pre>this<br>arguments</pre>
        </code>
      </div>

      <p class="note">
        * <code>NaN</code>, <code>Infinity</code>, <code>true</code>, <code>false</code>, <code>undefined</code> and <code>null</code> can also be put in this category.
      </p>
    </section>

    <section id="compound_literal_expressions" class="main-section">
      <header>
        <h2>Compound Literal Expressions</h2>
      </header>

      <p>
        Compound literals are literal expressions that consist of more than one token. They are still used to create values of various types, positioned as operands of operators or arguments of function calls.
      </p>

      <h4>Template string literals:</h4>

      <div class="code-block">
        <code>
          <pre>`With interpolated a=${a} and b=${b}`<br>`include calculated values ${a + b}, ${mult(a, b)}`</pre>
        </code>
      </div>

      <h4>Classic function literals: * ** ***</h4>

      <div class="code-block">
        <code>
          <pre>function fn() {}<br>function fn(a, b) {}<br>function fn(a, b = c) {}<br>function fn(a, ...b)<br>function fn([a], {b}) {}<br>function (a, b) {}<br>function Constructor(a, b) {}<br>function* generate() {}<br>async function doEventually() {}</pre>
        </code>
      </div>

      <p class="note">
        * to be considered a function literal and not a function declaration statement, it should be in an expression context, not just at the beginning of a separate line.
      </p>

      <p class="note">
        ** any classic function literal can be named or anonymous, with or without parameters, with or without async keyword, with or without asterisk making it a generator - any combination of these can be used.
      </p>

      <p class="note">
        *** any parameter in any function literal (classic or arrow) can utilize any kind of destructuring of any depth, be with or without default value; last parameter can be rest parameter with a rest operator in front of it.
      </p>

      <h4>Arrow function literals: *</h4>

      <div class="code-block">
        <code>
          <pre>a => b<br>() => {}<br>(a, b) => {}<br>async () => {}</pre>
        </code>
      </div>

      <p class="note">
        * in arrow function parentheses can be omitted if there is exactly one parameter, curly braces can be omitted if there is exactly one expression in the function body, and if curly braces are omitted the return value of that single expression is returned from the function.
      </p>

      <h4>Array literals: *</h4>

      <div class="code-block">
        <code>
          <pre>[a]<br>[a, b, c, d, e]<br>[...a, ...b, c]</pre>
        </code>
      </div>

      <p class="note">
        * any array literal can be written with arbitrary number of expressions providing elements inside, with or without spread operator in front of any of them.
      </p>

      <h4>Object literals: * ** ***</h4>

      <div class="code-block">
        <code>
          <pre>{a: b, c: d}<br>{a, b}<br>{...a, ...b, c}<br>{m(a) {}}<br>{async m() {}}<br>{*m() {}}<br>{get g() {}, set s(v) {}}</pre>
        </code>
      </div>

      <p class="note">
        * a property in an object literal can be written in shorthand form (without colon) if it has the same name as an existing binding in the same scope which will provide the value for that property; if spread operator is used instead of adding one property with specified name all the properties from the object provided next to that spread operator will be added to the object created
      </p>

      <p class="note">
        ** a method in an object literal can be written in shorthand form (without colon and function keyword), and it can be with or without parameters, with or without async keyword, with or without asterisk making it a generator in any combination of these; it will function as a function created with the function keyword.
      </p>

      <p class="note">
        *** an object literal can be written with or without getters and/or setters.
      </p>

      <h4>Class literals: * ** ***</h4>

      <div class="code-block">
        <code>
          <pre>class C {}<br>class {}<br>class C extends B {}<br>  <br>class C {<br>  p = a<br>  #pp = b<br>  constructor(a, b) {}<br>  m(a) {}<br>  static s(o) {}<br>  get g() {}<br>  set t(v) {}<br>}<br>  <br>class C {async m() {}; static async s() {}}<br>class C {*m() {}; static *s() {}}</pre>
        </code>
      </div>

      <p class="note">
        * to be considered a class literal and not a class declaration statement, it should be in an expression context, not just at the beginning of a separate line.
      </p>

      <p class="note">
        ** class literal can be named or anonymous, written with or without extends clause, with or without constructor, with or without static or prototype methods, with or without getters and/or setters, and with or without own property initializers.
      </p>

      <p class="note">
        *** any method in a class literal can be written with or without parameters, with or without async keyword, with or without asterisk making it a generator in any combination of these; it will function as a function created with the function keyword; constructor can be written with or without parameters, but can't be a generator or async function; own property initializers can be private or public (with or without a hash sign).
      </p>
    </section>

    <section id="operator_expressions" class="main-section">
      <header>
        <h2>Operator Expressions</h2>
      </header>

      <p>
        Operator expressions are expressions that consist of an operator and one or more operands. They are used to perform operations on operands and return a value and/or produce a side effect. They can and usually are informally named accordingly to the operator used.
      </p>

      <p>Groups of expressions by operator category:</p>

      <ul class="legend">
        <li> <code>arithmetic</code> </li>
        <li> <code>logical</code> </li>
        <li> <code>relational</code> </li>
        <li> <code>member access</code> </li>
        <li> <code>call</code> </li>
        <li> <code>assignment</code> </li>
        <li> <code>bitwise</code> </li>
        <li> <code>other...</code> </li>
      </ul>

      <h4>Arithmetic expressions:</h4>

      <div class="code-block">
        <code>
          <pre>a + b <span class="comment"> // addition expression</span><br>a - b <span class="comment"> // subtraction expression</span><br>a * b <span class="comment"> // multiplication expression</span><br>a / b <span class="comment"> // division expression</span><br><br>a % b <span class="comment"> // remainder expression</span><br>a ** b <span class="comment"> // exponentiation expression</span></pre>
        </code>
      </div>

      <h4>Logical expressions:</h4>

      <div class="code-block">
        <code>
          <pre>!a <span class="comment"> // logical negation expression</span><br><br>a && b <span class="comment"> // value selection by logical conjunction expression</span><br>a || b <span class="comment"> // value selection by logical disjunction expression</span><br>a ?? b <span class="comment"> // conditional value selection (if empty) expression</span><br><br>a ? b : c <span class="comment"> // ternary conditional value selection expression</span></pre>
        </code>
      </div>

      <h4>Relational expressions:</h4>

      <div class="code-block">
        <code>
          <pre>a < b <span class="comment"> // strict comparison expression</span><br>a > b <span class="comment"> // strict comparison expression</span><br>a <= b <span class="comment"> // non-strict comparison expression</span><br>a <= b <span class="comment"> // non-strict comparison expression</span><br><br>a == b <span class="comment"> // equality expression with coercion to same type</span><br>a === b <span class="comment"> // strict equality expression</span><br>a != b <span class="comment"> // inequality expression with coercion to same type</span><br>a !== b <span class="comment"> // strict inequality expression</span></pre>
        </code>
      </div>

      <h4>Member access expressions:</h4>

      <div class="code-block">
        <code>
          <pre>a.b <span class="comment"> // property read expression</span><br>a?.b <span class="comment"> // conditional (non-emptiness) property read expression</span><br>a[b] <span class="comment"> // read property via key expression</span><br>a?.[b] <span class="comment"> // conditional (non-emptiness) indexed element read</span><br><br>delete a <span class="comment"> // global variable deletion expression</span><br>delete a.b <span class="comment"> // property deletion expression</span><br>delete a[b] <span class="comment"> // property deletion via key (index) expression</span><br><br>a in b <span class="comment"> // membership check expression</span><br><br>a instanceof A <span class="comment"> // inheritance check by class</span></pre>
        </code>
      </div>

      <h4>Assignment expressions: *</h4>

      <div class="code-block">
        <code>
          <pre>a = b <span class="comment"> // assignment expression</span><br><br>a += b <span class="comment"> // specified increment expression</span><br>a -= b <span class="comment"> // specified decrement expression</span><br>a *= b <span class="comment"> // specified product reassignment expression</span><br>a /= b <span class="comment"> // specified division reassignment expression</span><br><br>a %= b <span class="comment"> // specified remainder reassignment expression</span><br>a **= b <span class="comment"> // specified exponentiation reassignment expression</span><br><br>a &&= b <span class="comment"> // logical conjunction reassignment expression</span><br>a ||= b <span class="comment"> // logical disjunction reassignment expression</span><br>a ??= b <span class="comment"> // conditional (if empty) reassignment expression</span><br><br>a &= b <span class="comment"> // bitwise AND reassignment expression</span><br>a |= b <span class="comment"> // bitwise OR reassignment expression</span><br>a ^= b <span class="comment"> // bitwise XOR reassignment expression</span><br><br>a >>= b <span class="comment"> // bit shift right reassignment expression</span><br>a <<= b <span class="comment"> // bit shift left reassignment expression</span><br>a >>>= b <span class="comment"> // bit shift right reassignment with sign drop</span><br><br>a.b = c <span class="comment"> // property assignment expression</span><br>a[b] = c <span class="comment"> // property assignment via key (index) expression</span><br><br>[a] = b <span class="comment"> // first element destructuring expression</span><br>[a, b] = c <span class="comment"> // iterable destructuring expression</span><br>[,,a] = b <span class="comment"> // iterable destructuring skipping first elements</span><br>[a,...b] = c <span class="comment"> // iterable destructuring with rest of<br>             // values collected in an array</span><br>{a} = b <span class="comment"> // single property destructuring expression</span><br>{a, b} = c <span class="comment"> // object destructuring expression</span><br>{a, ...b} = c <span class="comment"> // object destructuring with rest of<br>              // properties collected in an object</span><br>{a: b} = c <span class="comment"> // object destructuring with differently<br>           // named property/variable</span><br>[[a]] = b <span class="comment"> // deep iterable destructuring expression</span><br>[{a}] = b <span class="comment"> // deep object destructuring from an iterable</span><br>{a: [b]} = c <span class="comment"> // deep iterable destructuring from an object</span><br>{a: {b}} = c <span class="comment"> // deep object destructuring expression</span></pre>
        </code>
      </div>

      <p class="note">
        * any destructuring assignment expression can be written for arbitrary depth with arbitrary number of elements/properties being accessed in the left-hand side, with or without rest operator in front of the last one, with or without propety-to-variable name change.
      </p>

      <h4>Call expressions: *</h4>

      <div class="code-block">
        <code>
          <pre>a() <span class="comment"> // function call expression</span><br>a(b) <span class="comment"> // function call expression with single argument</span><br>a(b, c) <span class="comment"> // function call expression with multiple arguments</span><br>a(...b) <span class="comment"> // call expression with iterable arguments spread</span><br>a?.() <span class="comment"> // conditional (non-emptiness) call expression</span><br><br>a.b() <span class="comment"> // method call expression</span><br>a[b]() <span class="comment"> // method call via key expression</span><br><br>new C <span class="comment"> // object (class) instantiation expression</span><br>new C() <span class="comment"> // object (class) instantiation expression</span><br><br>super() <span class="comment"> // extended class instantiation expression</span><br><br>import(a) <span class="comment"> // module import expression</span></pre>
        </code>
      </div>

      <p class="note">
        * any call with parentheses syntactically can be without arguments, with one or more arguments, with or without spread operator in front of each argument.
      </p>

      <h4>Bitwise expressions:</h4>

      <div class="code-block">
        <code>
          <pre>a &amp; b <span class="comment"> // bitwise AND expression</span><br>a | b <span class="comment"> // bitwise OR expression</span><br>a ^ b <span class="comment"> // bitwise XOR expression</span><br><br>~a <span class="comment"> // bitwise NOT expression</span><br><br>a &lt;&lt; b <span class="comment"> // bit shift left expression</span><br>a &gt;&gt; b <span class="comment"> // bit shift right expression</span><br>a &gt;&gt;&gt; b <span class="comment"> // bit shift right expression with sign drop</span></pre>
        </code>
      </div>

      <h4>Other unary expressions:</h4>

      <div class="code-block">
        <code>
          <pre>typeof a <span class="comment"> // type determination expression</span><br><br>+a <span class="comment"> // coercion to number expression</span><br>-a <span class="comment"> // unary negation expression</span><br><br>++a <span class="comment"> // pre-increment expression</span><br>--a <span class="comment"> // pre-decrement expression</span><br>a++ <span class="comment"> // post-increment expression</span><br>a-- <span class="comment"> // post-decrement expression</span><br><br>await p <span class="comment"> // await promise result expression</span><br><br>yield <span class="comment"> // generator yield expression</span><br>yield a <span class="comment"> // generator yield value expression</span></pre>
        </code>
      </div>
    </section>

    <section id="nested_expressions" class="main-section">
      <header>
        <h2>Nested Expressions</h2>
      </header>

    </section>

    <section id="statements" class="main-section">
      <header>
        <h2>Statements</h2>
      </header>

      <p>
        Statements are commands that perform some actions with side effects but do not return a value themselves. So, naturally, they can't be used instead of expressions as operands in bigger expressions.
      </p>

      <p>
        Not all keywords are making statements but all statements are built around certain keywords. And those keywords are always used in that way.
      </p>

      <p>Anywhere in the code a statement can be used, an expression can be used instead (not to the same results of course). But not the other way around.</p>

      <h3>Declaractions</h3>

      <h4>Variable declaration statements:</h4>

      <div class="code-block">
        <code>
          <pre>var a = b <span class="comment"> // variable declaration statement</span><br>const a = b <span class="comment"> // constant declaration statement</span><br>let a = b <span class="comment"> // block scope variable declaration statement</span></pre>
        </code>
      </div>
      
      <h4>Function declaration statements: *</h4>

      <div class="code-block">
        <code>
          <pre>function f() {} <span class="comment"> // function declaration statement</span><br>function f(a, b) {} <span class="comment"> // function statement with parameters</span><br>function f(a, b = c) {} <span class="comment"> // ...with a default parameter value</span><br>function* f() {} <span class="comment"> // generator function declaration statement</span><br>async function f() {} <span class="comment"> // asynchronous function declaration</span><br>function Constructor(a, b) {} <span class="comment"> // constructor declaration</span></pre>
        </code>
      </div>
      
      <p class="note">
        * to be considered a function declaration statement and not a function expression, it should be at the beginning of a separate line and have a name.
      </p>

      <h4>Class declaration statements: *</h4>

      <div class="code-block">
        <code>
          <pre>class C {} <span class="comment"> // class declaration statement</span><br>class C extends B {} <span class="comment"> // class extension with a sub class</span><br><br>class C {<br>  p = a <span class="comment"> // own property initialization</span><br>  #pp = b <span class="comment"> // private property initializer</span><br>  constructor(a, b) {} <span class="comment"> // constructor itself</span><br>  m(a) {} <span class="comment"> // instance method</span><br>  static s(o) {} <span class="comment"> // static method</span><br>  get g() {} <span class="comment"> // getter</span><br>  set t(v) {} <span class="comment"> // setter</span><br>}<br><br>class C {<br>  async m() {} <span class="comment"> // async instance method</span><br>  static async s() {} <span class="comment"> // async static method</span><br>}<br><br>class C {<br>  *m() {} <span class="comment"> // instance generator method</span><br>  static *s() {} <span class="comment"> // static generator method</span><br>}</pre>
        </code>
      </div>

      <p class="note">
        * to be considered a class declaration statement and not a class expression, it should be at the beginning of a separate line and have a name.
      </p>

      <h3>Flow control</h3>

      <h4>Conditional if statements:</h4>

      <div class="code-block">
        <code>
          <pre>if (a) {} <span class="comment"> // conditional block statement</span><br><br>if (a) {<br>} else {<br>} <span class="comment"> // if/else block statement with unmet condition block</span><br><br>if (a) {<br>} else if (b) {<br>} else if (c) {<br>} else {<br>} <span class="comment"> // multiconditional if-branching statement</span><br><br>if (a) b <span class="comment"> // conditional expression statement</span><br><br>if (a) b<br>else if (c) d<br>else d <span class="comment"> // multiconditional branching expressions statement</span>
        </code>
      </div>

      <h4>Conditional switch statements: *</h4>

      <div class="code-block">
        <code>
          <pre>switch (a) {} <span class="comment"> // switch statement</span><br><br>switch (a) {<br>  case b: expr1<br>  case d: expr2  <br>  default: expr3<br>} <span class="comment"> // switch statement with default branch</span><br><br>switch (a) {<br>  case b:<br>    statement1<br>  case c:<br>    statement2<br>    break<br>  case d:<br>    statement3<br>    statement4<br>    break<br>  default:<br>    statement5<br>} <span class="comment"> // switch statement with multiple branches</span></pre>
        </code>
      </div>

      <p class="note">
        * switch statement can be written with any number of case equality (strict) entry points, with one default entry point or without any entry points at all (pointless). After each entry point there can be any number of commands (statements or expressions) to be executed. Withot break statement (which is optional) commands following the next entry point will be executed too.
      </p>

      <h3>Loops</h3>

      <h4>While loop statements:</h4>

      <div class="code-block">
        <code>
          <pre>while (a) {} <span class="comment"> // while statement</span><br><br>while (condition) {<br>  statement1<br>  statement2<br>  statement3<br>} <span class="comment"> // while statement with multiple statements</span><br><br>do {} while (a) <span class="comment"> // do-while statement</span><br><br>do {<br>  statement1<br>  statement2<br>  statement3<br>} while (condition) <span class="comment"> // do-while with multiple statements</span></pre>
        </code>
      </div>

      <h4>For loop statements: *</h4>

      <div class="code-block">
        <code>
          <pre>for (a; b; c) {} <span class="comment"> // classic for loop with three commands</span><br><br>for (let a of b) {} <span class="comment"> // for-of loop over iterable elements</span><br><br>for (let a in b) {} <span class="comment"> // for-in loop over object keys</span><br><br>for (let i = a; i < b; a += c) {<br>  statements<br>} <span class="comment"> // for loop with index, condition and stepping</span><br><br>for ( ; ; ) {} <span class="comment"> // infinite loop</span><br><br>for ( ; ; ) {<br>  statement1<br>  statement2<br>  statement3<br>} <span class="comment"> // infinite loop with multiple statements</span></pre>
        </code>
      </div>
          
      <p class="note">
        * for loop can be written with or without initialization, condition and stepping (classic for loop), with or without curly braces if only one expression follows, with or without multiple statements, and with or without continue and/or break statements inside the loop.
      </p>

      <p>
        All five kinds of loops can be nested in any combination. All five kinds of loops can be infinite, which can lead to freezes of the runtime. Classic for loop and while loops would become infinite if the condition is always true and no break or throw statement is used inside the loop. If a loop is written inside a function it can also be broken with a yield or return statement. For-of loop can behave as an infinite loop if the iterable is getting filled with new values during the loop execution.
      </p>

      <h3>Flow interruption</h3>

      <h4>Interruptive control flow statements:</h4>

      <div class="code-block">
        <code>
          <pre>break <span class="comment"> // break to exit a switch statement or a loop</span><br>continue <span class="comment"> // continue statement to skip to the<br>         // next iteration of a loop</span><br>return a <span class="comment"> // return statement to end function execution and<br>         // optionally return a value</span><br>throw a <span class="comment"> // throw statement to end function execution and<br>        // throw an exception</span></pre>
        </code>
      </div>

      <h3>Exception handling</h3>

      <h4>Try-catch-finally statements:</h4>

      <div class="code-block">
        <code>
          <pre>try {} catch (a) {} <span class="comment"> // try-catch statement</span><br>try {} catch {} <span class="comment"> // try-catch statement with no exception type</span><br>try {} finally {} <span class="comment"> // try-finally statement</span><br>try {} catch {} finally {} <span class="comment"> // try-catch-finally statement</span></pre>
        </code>
      </div>

      <h3>Modularity</h3>
      
      <h4>Import statements:</h4>

      <div class="code-block">
        <code>
          <pre>import a from "b" <span class="comment"> // import single (default) binding</span><br>import * as a from "b" <span class="comment"> // import all from module as object</span><br>import "b" <span class="comment"> // execute module code only</span><br><br>import {a} from "b" <span class="comment"> // import one named binding from module</span><br>import {a, b, c} from "b" <span class="comment"> // import multiple bindings</span><br>import {a as b} from "b" <span class="comment"> // import with custom name</span></pre>
        </code>
      </div>

      <h4>Export statements:</h4>

      <div class="code-block">
        <code>
          <pre>export default a <span class="comment"> // export default statement</span><br>export {a} <span class="comment"> // export single named binding statement</span><br>export {a, b, c} <span class="comment"> // export multiple named bindings statement</span><br>export {a as b} <span class="comment"> // export single binding with renaming</span><br><br>export const a = b <span class="comment"> // export constant statement</span><br>export let a = b <span class="comment"> // export variable statement</span><br>export function f() {} <span class="comment"> // export function statement</span><br>export class C {} <span class="comment"> // export class statement</span><br><br>export * from "b" <span class="comment"> // export all from module statement</span><br>export {a} from "b" <span class="comment"> // transit export named binding</span><br>export {a as b} from "b" <span class="comment"> // transit export with renaming</span></pre>
        </code>
      </div>
    </section>
  </main>
</body>

<!-- TODO: for await, comments in expressions, nested expressions -->

</html>
